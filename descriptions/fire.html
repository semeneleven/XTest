
<p align=center><font size="5"><i>Коды Файра. Краткие теоретические сведения.</i></font></p>
<p align=center><font size="4"><b>Кодирование.</b></font></p>
<p>&nbsp;&nbsp;&nbsp; Циклические коды относятся к числу блоковых систематических кодов, в которых каждая комбинация кодируется самостоятельно (в виде блока) таким образом, что информационные (k) и контрольные (m) символы всегда находятся на определённых местах. В основу циклического кодирования положено использование неприводимого многочлена P(X), который применительно к циклическим кодам называется образующим многочленом (полиномом). В качестве информационных символов для построения циклических кодов берутся комбинации двоичного кода на все сочетания. Циклический код или закодированное сообщение F(X) можно образовать двумя способами:</p>
<ol>
  <li>Умножением одной из комбинаций двоичного кода на все сочетания ( комбинация Q(X) ), принадлежащей к той же группе того же кода, что и заданная ( комбинация G(X) ), на образующий многочлен P(X);</li>
  <li>Умножением заданной кодовой комбинации G(X) на одночлен X<sup>m</sup>, имеющий ту же степень, что и образующий многочлен P(X), с добавлением к этому произведению остатка от деления произведения X<sup>m</sup> · G(X) на образующий многочлен P(X). Таким образом, F(X) = Q(X) · P(X) = X<sup>m</sup> · G(X) + R(X).</li>
</ol>
<p>&nbsp;&nbsp;&nbsp; Коды Файра относятся к группе циклических кодов, позволяющих обнаруживать и исправлять одиночные пачки ошибок. Следовательно, процедура кодирования для кодов Файра аналогична стандартной процедуре кодирования циклических кодов. Образующий полином данного кода P(X) = P<sub>1</sub>(X) · (X<sup>C</sup> + 1), где P<sub>1</sub>(X) – неприводимый многочлен степени L. Из принципа построения кода следует, что:</p>
<ol>
  <li>L >= B<sub>s</sub>.</li>
  <li>C >= B<sub>s</sub> + B<sub>r</sub> - 1.</li>
</ol>
<p>&nbsp;&nbsp;&nbsp; Здесь где B<sub>r</sub> – длина пачки обнаруживемых ошибок, B<sub>s</sub> – длина пачки исправляемых ошибок. При этом С не должно делиться нацело на число e = 2<sup>L</sup> - 1. Неприводимый многочлен P<sub>1</sub>(X) выбирается из таблицы непридимых многочленов для циклических кодов. Длина кодовой комбинации n = НОК(e, C). Число контрольных символов m = С + 1.</p>
<p>&nbsp;&nbsp;&nbsp; <b>Пример кодирования</b></p>
<p>&nbsp;&nbsp;&nbsp;<b> </b>Необходимо закодировать
сообщение <font face="Courier New">101010</font> так, чтобы
имелась возможность обнаружить и исправить
пачку из 2-х ошибок.</p>
<p>&nbsp;&nbsp;&nbsp; Дан неприводимый полином P<sub>1</sub>(X)
= <font face="Courier New">111</font>. Условие L >= B<sub>s </sub>выполняется
( L = 2, B<sub>s</sub> = 2 ). C &gt;= B<sub>s</sub> + B<sub>r</sub> - 1 = 2 + 2
- 1 = 3. Для выполнения условия неделения C на 2<sup>L</sup> -
1 необходимо взять C = 4.</p>
<p>&nbsp;&nbsp;&nbsp; Образующий полином P(X) = P<sub>1</sub>(X) · (X<sup>4</sup> +
1) = <font face="Courier New">1110111</font>.</p>
<p>&nbsp;&nbsp;&nbsp; Выполним деление X<sup>m</sup> · G(X) на
P(X):</p>
<p><font face="Courier New">1 0 1 0 1 0 0 0 0 0 0 0 | 1 1 1 0 1 1 1<br>
1 1 1 0 1 1 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|--------------<br>
-------------&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br>
&nbsp; 1 0 0 0 1 1 0<br>
&nbsp; 1 1 1 0 1 1 1<br>
&nbsp; -------------<br>
&nbsp;&nbsp;&nbsp; 1 1 0 0 0 1 0<br>
&nbsp;&nbsp;&nbsp; 1 1 1 0 1 1 1<br>
&nbsp;&nbsp;&nbsp; -------------<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 0 1 0 1 0 0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 1 1 0 1 1 1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -------------<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 0 0 0 1 1 0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 1 1 0 1 1 1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -------------<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 1 0 0 0 1</font></p>
<p>&nbsp;&nbsp;&nbsp; Кодовая комбинация: F(X) = X<sup>m</sup> · G(X) +
R(X) = <font face="Courier New">101010110001</font>.</p>
<p>&nbsp;&nbsp;&nbsp; <i><b>Примечание. </b></i>Во всех
рассчетах при тестировании кодирования и
декодирования принимайте C = 4 и L = 2, т.е.
обнаруживается и исправляется 2 ошибки.</p>
<p align=center><font size="4"><b>Декодирование.</b></font></p>
<p>&nbsp;&nbsp;&nbsp; Идея обнаружения ошибок в принятом циклическом коде заключается в том, что при отсутствии ошибок закодированная комбинация F(X) делится на образующий многочлен P(X) без остатка. В этом случае контрольные символы отбрасываются, а информационные символы используются по назначению. Если произошло искажение принятой кодовой комбинации, то эта комбинация F(X) преобразуется в комбинацию H(X), которую можно представить как сумму двух многочленов: H(X) = F(X) + E(X), где E(X) – многочлен ошибок, содержащий столько единиц, сколько элементов принятой комбинации не совпадает с элементами в переданной комбинации. Декодирование циклических кодов можно осуществлять следующим образом:</p>
<ol>
  <li>Вычислить остаток (синдром) R(X). Если R(X) = 0, то комбинация принята без ошибок. Наличие остатка говорит о том, что комбинация принята искаженной.</li>
  <li>Подсчитать вес остатка W. Если W &lt;= s (s – число исправляемых ошибок), то принятую комбинацию складывают по модулю 2 с остатком и получают исправленную комбинацию.</li>
  <li>Если W > s, то производится циклический сдвиг на один символ влево и полученная после такого сдвига комбинация снова делится на образующий многочлен. Если после этого W &lt;= s, то циклически сдвинутую комбинацию складывают с остатком и затем после сложения обратно сдвигают на один символ вправо (возвращают на прежнее место). В результате получаем исправленную комбинацию.</li>
  <li>Если после циклического сдвига на один символ по прежнему W > s, то производятся дополнительные циклические сдвиги влево. При этом после каждого сдвига осуществляется деление полученной комбинации на P(X) и проверяется вес остатка. При W &lt;= s выполняются действия, указанные в пункте 3, с той лишь разницей, что обратных циклических сдвигов вправо необходимо будет сделать столько, сколько было сделано влево.</li>
</ol>
<p><b>Пример декодирования</b></p>
<p>&nbsp;&nbsp;&nbsp; Дан образующий полином P(X) = <font face="Courier New">1110111</font>.</p>
<p>&nbsp;&nbsp;&nbsp; Принята кодовая комбинация <font face="Courier New">101010110000</font>.</p>
<p>&nbsp;&nbsp;&nbsp; Выполним ее декодирование.</p>
<p><font face="Courier New">1 0 1 0 1 0 1 1 0 0 0 0 | 1 1 1 0 1 1 1<br>
1 1 1 0 1 1 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|--------------<br>
-------------&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br>
&nbsp; 1 0 0 0 1 0 1<br>
&nbsp; 1 1 1 0 1 1 1<br>
&nbsp; -------------<br>
&nbsp;&nbsp;&nbsp; 1 1 0 0 1 0 0<br>
&nbsp;&nbsp;&nbsp; 1 1 1 0 1 1 1<br>
&nbsp;&nbsp;&nbsp; -------------<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 0 0 1 1 0 0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 1 1 0 1 1 1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -------------<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 1 1 0 1 1 0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 1 1 0 1 1 1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -------------<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
1</font></p>
<p>&nbsp;&nbsp;&nbsp; Так как вес остатка равен 1, и
код способен исправлять одиночные ошибки,
то дополнительные сдвиги выполнять не
нужно. Исключая проверочные разряды,
декодированная комбинация будет равна <font face="Courier New">101010</font>.</p>

